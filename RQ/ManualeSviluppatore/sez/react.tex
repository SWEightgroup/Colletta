This section is intended to make the developer understand the working of the Colletta frontend, and to allow him or her to add functionalities  to the software package.
In order fully understand the contents below, the developer must have a certain degree of familiarity with React and Redux. If that's not the case, we strongly recommend the reader to at least acquire some basic knowledge on the topics.

\subsection{Directory tree}
\begin{figure}[H]
\centering
\begin{forest}
  for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    inner xsep=7pt,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=15pt},
  }  
[Frontend
	[src
		[actions
		]
		[assets
		]
		[constants
		]
		[helpers
		]
		[reducer
		]
		[store
		]
		[view
			[containers]
			[components]
		]
	]
]
\end{forest}
\caption{Frontend directory tree}
\label{fig:FrontDir}
\end{figure}

Each folder contains a specific set of files:
\begin{itemize}
	\item \textbf{actions:} the modules in this folder are responsible for creating and dispatching the actions to the reducers;
	\item \textbf{assets:} static files like font and images;
	\item \textbf{constants:} data collections and constants used in various part of the code, i.e. the label used for the translation;
	\item \textbf{helpers:} standard js functions or classes which have some use in the code, i.e. the label translator;
	\item \textbf{reducers:} all the reducers responsible for the creation of a new state;
	\item \textbf{store:} a single file creating and giving access to the centralized state;
	\item \textbf{view:} classes rendering the information in the store. They are divided in \textit{components} and \textit{containers}.	 The key point to bare in mind when talking about components and containers is the following: containers are "smart", they observe the store and can call actions; components, on the other hand, are basically just static functions.
\end{itemize}

\subsection{Modify or add features}
\subsubsection{Components}
Components extend the React \texttt{component} abstract class and implement the \texttt{render()} method. They can be viewed as a pure functions of the props passed by their father component or container. They do not have access to the store. When adding or modifying a component the following rules should be followed:
\begin{itemize}
	\item Since the global state of the application is managed by Redux, do not use or create the local state of the component. Instead, rely solely on the props;
	\item Helper functions may be defined in the component class, but none of them should call action creators or external resources such as API calls;
	\item All components must be placed in the \texttt{src/component} folder;
	\item Every component which needs to render some text must have a language prop to call to the translator module;
\end{itemize}
When adding a new component, one can start from the following snippet:
\begin{lstlisting}
import React, { Component } from 'react';
import _translator from '../../helpers/Translator';
class SampleComponent extends Component {

  render() {
    const { prop1,prop2,prop3 } = this.props;
    //Do stuff here
    return (
      <React.Fragment>
        {/* Stuff to render */}
      </React.Fragment>
    );
  }
}
export default SampleComponent;
\end{lstlisting}


\subsubsection{Containers}
Containers extend the React \texttt{component} abstract class and implement the \texttt{render()} method. They can read the store and alters its state via actions. Containers can also have props passed to them, just like a container. When adding or modifying a component the following rules should be followed:
\begin{itemize}
	\item Since the global state of the application is managed by Redux, do not use or create the local state of the container. Instead, rely solely on the props and on the store;
	\item The store and the actions should not be accessed directly for performance and readability reasons. Instead, the should be mapped to the props;
	\item All containers must be placed in the most appropriate \texttt{src/view/containers} sub-directory. Creation of new sub-directories is allowed if necessary.
\end{itemize}

When adding a new container, one can start from the following snippet:
\begin{lstlisting}
import React, { Component } from 'react';
import { connect } from 'react-redux';
import _translator from '../../../helpers/Translator';

class SampleContainer extends Component {

  render() {
    const { prop1, prop2, prop3, action1Prop, action2Prop } = this.props;
    // Do stuff
    return (
      // Stuff to render
    );
  }
}
const mapStateToProps = store => {
  return {
    prop1: store.object1,
    prop2: store.object2,
    prop3: store.object3
  };
};

const mapDispatchToProps = dispatch => {
  return {
    action1Prop: () => dispatch(action1()),
    action2Prop: () => dispatch(action2())
  };
};
//both action1 and action2 must be imported

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(SampleContainer);
\end{lstlisting}


\subsubsection{Rest API calls}
When implementing a new Rest API call (RAP from now on), the developer must stick to the following guidelines:
\begin{itemize}
	\item RAPs must be implemented inside an action creator and should not be put inside components or containers;
	\item RAPs must use the Axios module;
	\item RAPs must pass an authorization token (exception made for Login and SignUp) which is kept in the store. The snippet below will show clarify how;
	\item If a RAP does not need additional data, the data field should be replaced by \texttt{\{\}}, otherwise the response will display a 403 error.
\end{itemize}
When adding a new RAP, one can start from the following snippet:
\begin{lstlisting}
export const sampleActionCreator = objectToSend => {
  return dispatch => {
    axios
      .post(
        'http://localhost:8081/sample-call',
        {
          ...objectToSend
        },
        {
          headers: {
            'content-type': 'application/json',
            Authorization: store.getState().auth.token
          }
        }
      )
      .then(response => {
        // Maybe do something
        dispatch({ type: 'SAMPLE-ACTION', dataToDispatch });
      })
      .catch(() => {/* Handle Error Here*/});
  };
};
\end{lstlisting}


\subsubsection{Interface Language}
\subsubsection{Analysis Languages}




